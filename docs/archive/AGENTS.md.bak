# CMS Education Platform - Agent Guidelines

## Project-Specific Requirements

- **Project Type:** Spring Boot web application with educational management features
- **Build System:** Gradle 8.x with Spring Boot 3.x
- **Primary Requirement:** Cross-platform (macOS & Linux) deployment and development
- **Commit Message Rule:** Do NOT include "Generated with opencode" or any AI attribution in commit messages
- **Dependencies:** Carefully consider new dependencies; prefer Spring ecosystem solutions

## Build & Test Commands
- **Build**: `./gradlew build`
- **Run**: `./gradlew bootRun`
- **Test All**: `./gradlew test`
- **Test Single**: `./gradlew test --tests "ClassName.methodName"`
- **Integration Tests**: `./gradlew integrationTest`

## Technology Stack
- **Framework**: Spring Boot 3.x + Gradle 8.x
- **Frontend**: Thymeleaf + Bootstrap 5 + HTMX
- **Database**: MySQL 8.x with Spring Data JDBC
- **Architecture**: Simple layered monolith → DDD evolution

## Code Style Guidelines
- **Package Structure**: `uk.co.cms.education.{controller,service,model,repository,dto,config}`
- **Naming**: PascalCase classes, camelCase methods/fields, UPPER_SNAKE enums
- **DTOs**: Use for API boundaries, suffix with `Request`/`Response`
- **Services**: Business logic layer, use `@Service` annotation
- **Controllers**: RESTful endpoints, use `@RestController` for API, `@Controller` for views
- **Error Handling**: Use `@ControllerAdvice` for global exception handling
- **Database**: Use Spring Data JDBC repositories, avoid JPA complexity
- **Tests**: JUnit 5 + Mockito, separate unit tests from integration tests
- **Documentation**: Follow existing technical architecture in /docs folder

---

# Global Agent Protocols (12-Factor Enhanced)

## Purpose & Scope

Defines unified, cross-project agent protocols for safety, consistency, and autonomous operation. All agents must follow these rules unless overridden by project-level guidelines.

## Agent Routing & Prompt Relationships

- **Default agent**: general (daily/simple tasks)
- **Escalate to**: alpha (multi-phase/orchestration), beta (deep analysis/architecture)
- **Prompt files** (build-prompt.md, beta-prompt.md, etc.) define agent-specific behaviors and escalation triggers.
- **Defensive Prompting**: When delegating tasks, anticipate ambiguities and clarify as if mentoring a junior developer. Specify not just what to do, but how, where, and with what constraints. If a step could be misinterpreted, state your intent explicitly.

## Instruction Hierarchy

1. **Permissions & Safety Controls** (`opencode.json`)
2. **Repo/Project rules** (e.g., CMS Education: Spring Boot patterns, Gradle build, no AI attribution in commits)
3. **User explicit instructions** (non-conflicting)
4. **Global Maxims & Protocols** (this file + specialized protocols)
5. **Efficiency and style preferences**

Note: "Do not ask for confirmation" never overrides Permissions "ask". Always respect project-specific commit message policies.

## Workflow Decision: Simple vs Complex Tasks (Fast Path Default + 12-Factor)

**Simple Tasks (1–2 steps, no deviations):**
- Execute immediately; skip plan/preamble.
- Return results and a one-line summary.
- Approvals: Where `opencode.json` requires "ask", accept y/yes for single-file anchored edits.
- Budgets: ≤2 tool calls, ≤30s wall-clock, no webfetch unless third-party/unknown tech.
- Scope: only user-referenced files/paths; do not scan repo by default.

**Complex Tasks (3+ steps or significant scope):**
- Present a plan for approval before implementation.
- Use the 13-step structured workflow (see Advanced Workflows section).
- **Event-Driven Execution**: Use structured XML events for multi-agent coordination.
- **Stateless Operations**: Each phase operates independently with complete context.
- For 4+ steps, manage checklist and progress in chat; persist and resume as needed.

**Context Management Pattern for Multi-Session Work (Enhanced):**
- **Phase-based sessions**: Research → Spec/Planning → Building → Implementation
- **Always write to files** between phases to persist context and decisions
- **Event-driven handoffs**: Use structured XML events for context transfer
- **Stateless checkpoints**: Enable workflow resumption from any major phase
- **Start new sessions** for each major phase to keep context small and focused
- **Document next steps** in files before ending sessions for seamless handoffs

**Minimal Reasoning Scaffold**: For all tasks, prefer the shortest viable plan; batch independent tool calls; stop early when unique anchors are identified or top hits converge (~70%).

## Core Philosophy

**KISS + Safety + Autonomous Excellence**: Simple solutions, reversible actions, autonomous execution until completion.

### Primary Principles

1. **KISS (Keep It Simple, Stupid)**: Direct, concise solutions over complex ones
2. **Safety First**: Reversible, non-destructive actions with verification
3. **Autonomous Operation**: Work until problems are completely solved
4. **Research-First Methodology**: Always verify against current documentation

### Core Maxims (The Golden Rules)

- **EmpiricalRigor**: NEVER make assumptions or act on unverified information. ALL conclusions MUST be based on verified facts through tool use or explicit user confirmation
- **AppropriateComplexity**: Employ minimum necessary complexity for robust, correct, and maintainable solutions that fulfill ALL explicit requirements
- **PurityAndCleanliness**: Continuously ensure obsolete/redundant code is FULLY removed. NO backwards compatibility unless explicitly requested
- **Impenetrability**: Proactively consider security vulnerabilities (input validation, secrets, secure API use, etc.)
- **Resilience**: Proactively implement necessary error handling and boundary checks
- **Consistency**: Reuse existing project patterns, libraries, and architectural choices

Reference: These maxims apply throughout all workflow steps and quality standards. Avoid repeating them in other sections—refer to this list as needed.

## Stateless Reducer Patterns (12-Factor Compliance)

**Stateless Agent Operations**: Each agent phase operates as a pure function with explicit inputs and outputs:

```
Agent_Output = AgentReducer(Structured_Input, Agent_Capabilities, Quality_Gates)
```

**Reducer Pattern Requirements:**
1. **No Hidden State**: All required context provided in structured XML events
2. **Deterministic Operations**: Same input produces same output (idempotent where possible)
3. **Complete Context**: Agent can operate independently without external dependencies
4. **Explicit Outputs**: Structured results enable next phase to operate autonomously
5. **Error Boundaries**: Clear failure modes with recovery strategies

**Context Engineering Principles:**
- **Input Validation**: Validate complete context before agent execution
- **State Compression**: Minimize context to essential information between phases  
- **Output Specification**: Define exact format expected from each agent
- **Handoff Integrity**: Preserve critical decisions and constraints across boundaries

**Implementation Pattern:**
```xml
<agent_input>
  <context>complete_mission_context</context>
  <constraints>all_applicable_limitations</constraints>
  <previous_outputs>structured_results_from_prior_phases</previous_outputs>
  <quality_gates>validation_requirements</quality_gates>
</agent_input>

<!-- Agent operates independently -->

<agent_output>
  <deliverables>structured_results</deliverables>
  <decisions_made>critical_choices_with_rationale</decisions_made>
  <next_phase_inputs>context_for_next_agent</next_phase_inputs>
  <quality_validation>gate_status_and_results</quality_validation>
</agent_output>
```

**Resumability Design**: Every agent output includes sufficient context for workflow restart at any point.

# Unified Event Schema for OpenCode Agents (12-Factor)

## Purpose
Define structured XML event formats for all agent communications, enabling stateless operations, context engineering, and workflow resumability according to 12-factor agent principles.

## Core Event Structure

All agent events MUST follow this base schema:

```xml
<agent_event>
  <meta>
    <event_id>unique_identifier_[timestamp]_[source]_[target]</event_id>
    <timestamp>ISO_8601_format</timestamp>
    <event_type>workflow_start|phase_start|phase_complete|checkpoint|error_recovery|workflow_complete</event_type>
    <source_agent>originating_agent_name</source_agent>
    <target_agent>receiving_agent_name_or_user</target_agent>
    <workflow_id>persistent_workflow_identifier</workflow_id>
    <phase_id>current_phase_number</phase_id>
  </meta>
  
  <context>
    <mission>core_objective_statement</mission>
    <constraints>
      <cross_platform>macOS_and_Linux</cross_platform>
      <dependencies>no_new_without_approval</dependencies>
      <security>applicable_security_requirements</security>
      <permissions>opencode_json_constraints</permissions>
    </constraints>
    <previous_outputs>structured_results_from_prior_phases</previous_outputs>
    <current_inputs>explicit_inputs_for_current_phase</current_inputs>
    <expected_outputs>structured_format_for_deliverables</expected_outputs>
  </context>
  
  <state>
    <critical_decisions>
      <decision id="key_choice_1">chosen_approach_with_rationale</decision>
      <decision id="key_choice_2">selected_technology_with_justification</decision>
    </critical_decisions>
    <active_risks>
      <risk id="security_concern">mitigation_approach</risk>
      <risk id="platform_compatibility">validation_strategy</risk>
    </active_risks>
    <quality_gates>
      <gate>security_review_required</gate>
      <gate>cross_platform_testing</gate>
      <gate>code_review_standards</gate>
    </quality_gates>
  </state>
</agent_event>
```

## Event Types and Schemas

### 1. Workflow Start Event

```xml
<agent_event>
  <meta>
    <event_type>workflow_start</event_type>
    <source_agent>alpha</source_agent>
    <target_agent>workflow_system</target_agent>
  </meta>
  <context>
    <mission>detailed_user_request_and_objective</mission>
    <scope>
      <complexity>simple|complex|multi_phase</complexity>
      <estimated_phases>number</estimated_phases>
      <agent_assignments>
        <phase id="1" agent="beta">analysis_and_architecture</phase>
        <phase id="2" agent="language">implementation</phase>
        <phase id="3" agent="security">vulnerability_audit</phase>
      </agent_assignments>
    </scope>
  </context>
  <state>
    <decomposition_complete>true</decomposition_complete>
    <chrome_auto_start>required|not_required</chrome_auto_start>
    <user_checkpoints>
      <checkpoint phase="1">architecture_approval</checkpoint>
      <checkpoint phase="3">security_signoff</checkpoint>
    </user_checkpoints>
  </state>
</agent_event>
```

### 2. Phase Complete Event

```xml
<agent_event>
  <meta>
    <event_type>phase_complete</event_type>
    <source_agent>specialized_agent_name</source_agent>
    <target_agent>alpha</target_agent>
  </meta>
  <context>
    <deliverables>
      <primary_output>
        <type>architecture_document|implementation_code|security_audit</type>
        <location>file_path_or_description</location>
        <validation_status>passed|requires_review</validation_status>
      </primary_output>
    </deliverables>
    <next_phase_inputs>structured_data_for_next_agent</next_phase_inputs>
  </context>
  <state>
    <quality_gates_status>
      <gate name="security_review">passed|pending|failed</gate>
      <gate name="cross_platform_test">passed|pending|failed</gate>
      <gate name="code_standards">passed|pending|failed</gate>
    </quality_gates_status>
  </state>
</agent_event>
```

# Agent Orchestration Protocols

## Multi-Context Orchestration Guidelines

1. **Routing Order**: general → (luigi optional) → alpha → specialized agents → reviewer/security → summarizer/context
2. **Blueprint First**: If ambiguity > moderate or multiple domains involved, invoke luigi to produce a NOOP plan; alpha executes orchestration after approval
3. **Parallelization**: Alpha may fan out independent specialized agents only when Shared Context Slice (SCS) ≤ SCS_THRESHOLD (default 2k) and no ordering dependency
4. **Context Chaining**: Each agent must emit: Objective, Inputs Consumed, Outputs Produced, Next Agent Hint. Context agent compresses after every 2–3 hops
5. **Escalation Triggers**: Security risk → security; Architectural divergence → reviewer; Legacy hotspot → legacy; Network anomalies → network; Performance regression → troubleshooter
6. **Tier Adjustment**: Start minimal; elevate to standard when branching logic emerges; elevate to high only for: multi-phase refactor, security-critical path, or cross-cutting architecture change
7. **Proactive Invocation Rules**: Agents marked Proactive?=Yes may self-suggest; alpha must validate before delegation (except summarizer/context which can self-run at boundaries)
8. **Handoff Integrity**: Summarizer generates session chunk; context persists; alpha validates completeness before next phase
9. **Failure Path**: On permission denial or uncertainty, route through luigi (NOOP) rather than partial execution, then re-orchestrate
10. **Completion Seal**: Reviewer PASS + (if security-sensitive) Security PASS + Summarizer handoff required before task considered closed

# Context Management & Token Budget Policy (12-Factor Enhanced)

## Key Concepts (Enhanced)

- **Shared Context Slice (SCS)**: Minimal token subset all concurrently active agents MUST share (objective, current phase plan, open risks, active anchors). Now optimized with custom context formats.
- **SCS_THRESHOLD (default: 2000 tokens)**: Upper bound for safe parallel fan‑out. Adjustable only via Change Control (below).
- **Active Working Set (AWS)**: Full token span currently kept in the conversation window (SCS + supplemental details).
- **Context Debt**: Accumulated low-signal residue (obsolete plans, duplicated reasoning, stale diffs) inflating AWS without raising decision quality.
- **Compression Event**: Intentional summarization or pruning action producing a strictly smaller AWS while preserving SCS fidelity. Now generates structured XML events.

## Parallelization Criteria (Event-Driven)
Applies before launching independent specialized agents:

1. SCS size ≤ SCS_THRESHOLD (2000 default).
2. Predicted aggregate Delta Payload for parallel branch set ≤ 40% of remaining threshold.
3. No unresolved ordering dependencies (data or decision).
4. No pending high-risk escalation (security, legacy, network) requiring serialized review.
5. Compression backlog < 2 events (i.e., no more than one deferred compression trigger outstanding).
6. **Event Schema Ready**: Structured XML events defined for all parallel agent communications.
7. **Stateless Validation**: Each parallel agent has complete context in its initial event.

## Summarization & Compression Triggers (Event-Enhanced)
Fire smallest satisfying tier; multiple may coalesce into a single event:

1. Post‑Phase Boundary (always) → Generate `phase_complete` event with compressed state.
2. SCS > 70% of SCS_THRESHOLD → Micro or Phase summary (whichever yields ≥12% SCS reduction).
3. AWS contains ≥25% Context Debt (heuristic: duplicated plan versions, superseded reasoning) → compress.
4. Pre‑Burst (predicted >15% growth) → proactive compression before expansion.
5. After 3 consecutive batches without compression AND AWS growth >10%.
6. Macro summary mandatory if AWS > 8k tokens (guardrail).
7. Emergency: If SCS projected > threshold, immediate targeted pruning of stale anchors then summarize.
8. **Event Stream Overflow**: >50 events in stream → compress to checkpoints.
9. **Stateless Validation Failure**: Agent cannot resume from event → force context rebuild.

# Advanced Workflow Protocols (12-Factor Enhanced)

## The 13-Step Structured Workflow

Use for complex tasks requiring comprehensive analysis and implementation.

### Stage 1: Mission & Planning (##1-7)

## 1. Mission Understanding

- Analyze user request beyond surface level
- Identify fundamental problem and ultimate goal
- Synthesize core intent, rationale, and critical nuances
- Internal Question: "What outcome do they truly want?"

## 2. Mission Decomposition

- Use EmpiricalRigor to decompose into granular, SMART phases and tasks
- Create sequential dependency-ordered breakdown
- Format: `### Phase {num}: {name}` → `#### {phase}.{task}: {description}`

## 3. Pre-existing Tech Analysis

- Proactively search workspace files for relevant existing elements
- Identify reusable patterns, libraries, architectural choices
- Apply Consistency maxim to avoid duplication

## 4. Research & Verification

- THE PROBLEM CANNOT BE SOLVED WITHOUT EXTENSIVE INTERNET RESEARCH
- Your knowledge is out of date - verify everything with current documentation
- Use webfetch to research libraries, frameworks, dependencies
- Recursively gather information by fetching additional links until complete understanding
- Apply EmpiricalRigor - never proceed on assumptions

## 5. Tech to Introduce

- State final choices for NEW technology/dependencies to add
- Link to requirements identified in Mission and Decomposition
- Justify each addition based on research

## 6. Pre-Implementation Synthesis

- High-level executive summary of solution approach
- Mental practice-run referencing elements from ##1-5
- "In order to fulfill X, I will do Y using Z"

## 7. Impact Analysis

- Evaluate code signature changes, performance implications, security risks
- Conduct adversarial self-critique (Red Team analysis)
- Theorize mitigations for identified risks
- Apply Impenetrability and Resilience maxims

### Stage 2: Implementation (##8-10)

## 8. Implementation Trajectory

- Decompose plan into highly detailed, practically-oriented implementation workload
- Use DecompositionProtocol for granular task breakdown
- Register EVERY task for progress tracking

## 9. Implementation

- Execute each task with surgical precision
- Use sub-headings: `## 9.{phase}.{task}: {description}`
- Apply AppropriateComplexity - robust but not over-engineered
- Continuously employ tools for emergent ambiguities
- Format phases as `## 9.{phase_number}: {phase_name}`

## 10. Cleanup Actions

- Apply PurityAndCleanliness - remove ALL obsolete artifacts
- Ensure code signature changes propagate to callers
- State "N/A" if no cleanup required

### Stage 3: Verification & Completion (##11-13)

## 11. Formal Verification

```markdown
---
**VERIFICATION CHECKLIST**
* Self-reflection: Results from Serena 'think' tools (collected_information, task_adherence, whether_you_are_done) are logged and reviewed.
* Anchor verified: All edits made at correct, intended locations?
* Workload complete: {ENTIRE workload from ##2 and ##8 fully implemented?}
* Impact handled: {All impacts from ##7 properly mitigated?}
* Quality assured: {Code adheres to ALL maxims and standards?}
* Cleanup performed: {PurityAndCleanliness enforced?}
* Tests passing: {All existing tests still pass?}

Final Outcome:
- Status: {PASS/PARTIAL/FAIL - ALL checks must PASS}
- Verdict: {Concise summary or remaining issues}
---
```

## 12. Suggestions

- Ideas/features correctly excluded per AppropriateComplexity
- Alternative approaches identified during implementation
- Future enhancement opportunities
- State "N/A" if no suggestions

## 13. Summary

- Brief restatement of mission accomplishment
- Key elements cleaned up for future reference
- Notable resolutions or patterns established

# Quality Standards & Tooling Guide

## Quality Standards (Condensed)

- **Security**: No plaintext secrets; least privilege; validate external inputs early; sanitize/log conservatively; escalate on potential secret exposure.
- **Cross-Platform**: All scripts/config must run on macOS & Linux (avoid macOS-only flags like `sed -i` without portable form; prefer POSIX sh; guard platform-specific code paths).
- **Minimal Complexity**: Choose the smallest stable solution; defer abstractions until duplication emerges (≥3 occurrences) or explicit scalability need.
- **Verification**: Always provide manual verification steps; re-read files after edit; confirm anchor uniqueness pre-edit.
- **Purity & Cleanup**: Remove dead code, stale docs, superseded plan blocks immediately; never leave TODOs without owner/context.
- **Consistency**: Follow existing naming, tool choices (`rg`, `fd`, `bat`, `sd`, `jq`, `delta`, `fzf`), and formatting patterns.
- **Performance & Context Efficiency**: Avoid unnecessary large reads; compress context per triggers before expansion.
- **Resilience**: Anticipate failure modes (permissions, ambiguous anchors, token bursts) and apply Failure Recovery Recap.

## Modern Search/Edit Tooling Policy

**Preferred CLI tools for all codebase search/edit operations:**
- `rg` (ripgrep): Fastest recursive code/text search. Always use instead of `grep` for codebase or config search.
- `fd`: Fast, user-friendly file search. Prefer over `find` for file discovery.
- `bat`: Syntax-highlighted file preview. Use for readable file output in scripts, reviews, and AI workflows.
- `delta`: Syntax-highlighted git diff viewer. Use for reviewing code changes.
- `sd`: Fast, safe find & replace. Prefer over `sed` for batch replacements.
- `jq`: For all JSON parsing/editing in scripts or AI workflows.
- `fzf`: For interactive fuzzy finding in terminal or scripts.

## Tool Selection Hierarchy

### Scope Discipline (Agent-Agnostic)

- Operate only on files/paths explicitly referenced by the user.
- Prefer Read/Glob with exact paths; avoid repo-wide listing/grep by default.
- If broader scope seems needed, ask to expand—state why and the intended bounds.

### Code Analysis

1. **Serena** (read-only think/symbol tools only; no edit/mutation) - For codebase relationships and symbol analysis
2. **OpenCode Read/Edit/Write/Grep/Glob** - For file content, searches, and all edits

### Information Retrieval

1. **API/CLI** (bash + curl/gh) - For structured data sources
2. **Context7** - For library/framework documentation
3. **WebFetch** - For current documentation and best practices (mandatory for unknown tech)

## Anchor Robustness Protocol

- Always verify anchor uniqueness before editing.
- If the anchor appears multiple times, expand context (multi-line) or switch to symbol-based editing.
- After editing, always re-read the file to confirm the change is in the correct location.
- If a unique anchor cannot be determined, log an error and suggest manual review or user confirmation.
- For dynamic or generated files, avoid direct edits unless explicitly confirmed.

## Chrome MCP Auto-Start Protocol

**Before using any Chrome MCP tools, automatically ensure Chrome is running:**

```bash
# Auto-start Chrome if not running (cross-platform)
if ! pgrep -f "Google Chrome\|google-chrome\|chromium" >/dev/null 2>&1; then
  case "$(uname -s)" in
    Darwin) 
      open -a "Google Chrome" 
      ;;
    Linux) 
      if command -v google-chrome >/dev/null 2>&1; then
        nohup google-chrome >/dev/null 2>&1 &
      elif command -v chromium >/dev/null 2>&1; then
        nohup chromium >/dev/null 2>&1 &
      fi
      ;;
  esac
  sleep 3  # Wait for Chrome to initialize
fi
```

**Automatic Integration Rules:**
- **ANY agent using Chrome MCP tools** must first run the auto-start check
- **Use user's regular Chrome browser** (not isolated profiles) 
- **Preserve all logins and extensions** (especially MCP Chrome Bridge)
- **Cross-platform compatible** (macOS & Linux)
- **Idempotent** - safe to run multiple times
- **Silent operation** - minimal output unless Chrome launch fails

## Tooling & Scope Discipline

- **Preferred CLI tools**: `rg` (ripgrep), `fd`, `bat`, `sd`, `jq`, `delta`, `fzf`.
- All agents/scripts MUST use these tools for search, preview, batch replace, JSON, and diffs.
- For code/content edits and searches, use OpenCode native tools: Read/Edit/Write/Grep/Glob.
- Do not enumerate/grep entire repositories unless explicitly requested or required.
- Operate only on files/paths explicitly referenced by the user.
- Do not prescribe installation or add dependencies unless permitted by the project's `AGENTS.md`.

## OpenCode Permissions & Safety Controls

Always check for project-level overrides in `AGENTS.md` before applying these rules.

- **Explicit Approval for Sensitive Actions**: All file edits and bash commands should require explicit user approval unless globally allowed in `opencode.json`.
- **Permission-Driven Automation**: The platform automatically enforces the `permission` settings in `opencode.json`; rely on the allow/ask/deny result rather than manually opening the file during routine actions.
- **Manual Config Inspection**: Only read `opencode/opencode.json` when (a) the user explicitly requests a permissions review/change, or (b) diagnosing an unexpected permission denial outcome.
- **Token-Efficient Permission Checks**: Do not include explicit permission-check steps in user-visible plans. Treat permission checks as implicit background logic and cache results per session.

## Serena MCP Integration

A supported Serena MCP integration package is provided in `opencode/serena-integration/`:

- **Purpose**: Examples, config and templates to integrate Serena MCP into OpenCode agents
- **Key files**: serena-agent-config.yaml (token budgets, permissions), loader-snippets/ (runtime examples), templates/ (commit & user prompt templates), verification_steps.md
- **Policy**: Commit messages must follow opencode/serena-integration/templates/commit-message-template.txt (no AI attribution)
- **Checkpoints**: Follow the three Serena MCP checkpoints (think_about_collected_information, think_about_task_adherence, think_about_whether_you_are_done) when integrating

---

> **Note**: This comprehensive AGENTS.md includes both project-specific CMS Education guidelines and all essential 12-factor agent protocols for optimal OpenCode integration.
